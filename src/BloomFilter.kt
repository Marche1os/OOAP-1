interface BloomFilter<T> {

    // Конструктор

    // Постусловие: создан битовый массив размера [length]
    fun BloomFilter(length: Int): BloomFilter<T>

    // Команды

    // Постусловие: элемент добавлен в фильтр
    fun add(value: T)

    // Предусловие: список хэш-функций должен быть не пустым.
    fun setHashFunctions(hashFunctions: List<(T) -> Int>)

    // Запросы

    // Имеется ли значение в фильтре
    fun isValue(value: T): Boolean

    // Статусы
    fun getSetHashFunctionsStatus() // OK, список хэш-функций пуст
}

/**
 * Рефлексия
 *
 * В эталонном решении понравилось, что есть пояснение, что is_value может возвращать ложноположительный результат.
 * Такое пояснение полезно при проектировании некой структуры данных, у которых есть такие побочные эффекты.
 *
 * Помимо этого, я решил дополнительно указать о необходимости реализации хэш-функций, которые используются в фильтре Блума.
 *
 * В целом, мое решение соответствует эталонному, можно сказать, что АТД "Фильтр Блума" описан корректно.
 */

/**
 * Эталонное решение
 *
 * abstract class BloomFilter<T>
 *
 *   // конструктор
 * // постусловие: создан пустой фильтр Блюма заданного размера
 *   public BloomFilter<T> BloomFilter(int sz);
 *
 *   // команды
 * // постусловие: в фильтр добавлено новое значение
 *   public void put(T value);
 *
 *   // запросы
 * public bool is_value(T value);
 *   // содержится ли значение в фильтре
 *   // (допускаются ложноположительные срабатывания)
 */