interface DynArray<T> {
    val array: Array<T>

    // команды:

    // предусловие: элемент, который нужно добавить, не должен быть равен null
    // постусловие: размер массива увеличивается на 1, элемент добавляется в конец
    // происходит реаллокация массива, если достигнут верхний порог заполненности
    fun add(value: T)

    // предусловие: элемент, который нужно добавить, не должен быть равен null, индекс лежит в диапазоне [0..capacity - 1]
    // постусловие: размер массива увеличивается на 1, элемент добавляется после указанногоо индекса
    // происходит реаллокация массива, если достигнут верхний порог заполненности
    fun addInIndex(value: T, index: Int)

    // предусловие: индекс лежит в диапазоне [0..capacity - 1]
    // элемент, который нужно установить, не должен быть равен null
    // постусловие: элемент, находящийся по заданному индексу, заменяется на новый элемент
    fun set(value: T, index: Int)

    // предусловие: индекс лежит в диапазоне [0..capacity - 1]
    // постусловие: размер массива уменьшается на 1, элемент, находящийся по заданному индексу, удаляется
    // происходит реаллокация массива, если достигнут нижний порог заполненности
    fun remove(index: Int)

    // предусловие: элемент, который нужно найти, не может быть равен null
    // постусловие: возвращается индекс первого найденного элемента, соответствующего заданному,
    // или -1, если такой элемент не найден
    fun indexOf(value: T): Int

    // запросы:

    // предусловие: индекс лежит в диапазоне [0..capacity - 1]
    // постусловие: возвращается элемент, находящийся по заданному индексу,
    fun get(index: Int): T

    fun getCount(): Int

    fun getCapacity(): Int

    // запросы статусов (и возможные статусы):

    fun getAddStatus(): Int // успех;
    fun getAddInIndexStatus(): Int // успех; ошибка
    fun getSetStatus(): Int // успех; ошибка
    fun getRemoveStatus(): Int // успех; ошибка;
    fun getIndexOfStatus(): Int // успех, не найден элемент
}

sealed interface ReallocationStrategy<T> {
    interface Additive<T> : ReallocationStrategy<T> {
        fun resize(array: DynArray<T>)
    }

    interface Multiplicative<T> : ReallocationStrategy<T> {
        fun resize(array: DynArray<T>)
    }
}

/**
 * Рефлексия
 *
 * В моем решении отсутствует явный конструктор. Его присутствие вносит чуть больше ясности в наш тип данных
 * Пред- пост- условия заданы корректно.
 * Да, команды отличаются, но незначительно. Указанные в моем решении команды также удовлетворяют требованиям того, что должен уменить АТД "Динамический массив"
 * Правильно, что тип является обобщенным, то есть работает с множеством типов. Не с конкретным.
 * В моем решении менее явно задано множество значений статуса команды. При проектировании, думаю, следовало это учесть и расширить множество значений статуса выполнения команды.
 * Но полнота этих значений также может меняться в зависимости от проекта/задачи.
 *
 */

/**
 * Решение
 *
 * abstract class DynArray<T>
 *
 *   // конструктор
 * // постусловие: создан пустой массив
 *   public DynArray<T> DynArray();
 *
 *   // команды
 * // предусловие: i лежит в допустимых границах массива;
 * // постусловие: значение элемента i изменено на value
 *   public void put(i, T value);
 *
 * // предусловие: i лежит в допустимых границах массива;
 * // постусловие: перед элементом i добавлен
 * // новый элемент с значением value;
 *   public void put_left(i, T value);
 *
 * // предусловие: i лежит в допустимых границах массива;
 * // постусловие: после элемента i добавлен
 * // новый элемент с значением value;
 *   public void put_right(i, T value);
 *
 * // предусловие: нет;
 * // постусловие: в хвост массива добавлен
 * // новый элемент
 *   public void append(T value);
 *
 * // предусловие: i лежит в допустимых границах массива;
 * // постусловие: элемент i удалён из массива;
 *   public void remove(int i);
 *
 *   // запросы
 * // предусловие: i лежит в допустимых границах массива;
 *   public T get(int i); // значение i-го элемента
 *   public int size(); // текущий размер массива
 *
 *   // запросы статусов (возможные значения статусов)
 *   public int get_put_status(); // успешно; индекс за пределами массива
 *   public int get_put_left_status(); // успешно; индекс за пределами массива
 *   public int get_put_right_status(); // успешно; индекс за пределами массива
 *   public int get_remove_status(); // успешно; индекс за пределами массива
 *   public int get_get_status(); // успешно; индекс за пределами массива
 */