interface HashTableBase<T> {

    //конструктор

    //постусловие: создана пустая хэш-таблица заданного размера
    fun HashTable(sz: Int): HashTableBase<T>

    // команды

    //предусловие: в таблице имеется свободный слот для value;
    //постусловие: в таблицу добавлено новое значение
    fun put(value: T)

    //предусловие: в таблице имеется значение value;
    //постусловие: из таблицы удалено значение value
    fun remove(value: T)

    //запросы

    fun get(value: T): Boolean; // содержится ли значение value в таблице
    fun size(): Int; // количество элементов в таблице

    //запросы статусов (возможные значения статусов)
    fun get_put_status(): Int; // успешно;

    //система коллизий не смогла найти свободный слот для значения
    fun get_remove_status(): Int; // успешно; значения нету в таблице
}

interface PowerSet<T> : HashTableBase<T> {

    // Конструктор
    // Постусловие: создано пустое множество
    fun PowerSet(maxSize: Int): PowerSet<T>

    // Команды

    // Предусловие: добавляемое значение отсутствует в множестве и текущее количество элементов меньше максимально допустимого размера
    // Постусловие: добавлен элемент в множество
    override fun put(value: T)

    // Запросы

    // Чистая функция. Возвращает пересечение множеств
    fun intersection(set: PowerSet<T>): PowerSet<T>

    // Чистая функция. Возвращает объединение двух множеств
    fun union(set: PowerSet<T>): PowerSet<T>

    // Чистая функция. Возвращается подмножество текущего множества из таких элементов, которые не входят в множество-параметр
    fun difference(set: PowerSet<T>): PowerSet<T>

    // Чистая функция. Проверяется, входят ли все элементы множества-параметра в текущее множество (будет ли множество-параметр подмножеством текущего множества)
    fun isSubset(set: PowerSet<T>): PowerSet<T>

    // Статусы

    override fun get_put_status(): Int // OK, добавляемый элемент уже присутствует в множестве
}

/**
 * Рефлексия
 *
 * В своем решении правильно определил основные операции множества: intersection, union, difference, isSubset в плане пред- пост- условий.
 * Указал, что это чистые функции, не изменяют внутреннее состояние структуры данных.
 * Дополнительно переопределил команду put, чтобы показать ее ограничения в предусловии.
 *
 * В остальном, мое решение соответствует эталонному, АТД "Множество" описан корректно.
 */


/**
 * Эталонное решение
 *
 * abstract class PowerSet<T> : HashTable<T>
 *
 *   // конструктор
 * // постусловие: создано пустое множество
 * // на максимальное количество элементов sz
 *   public PowerSet<T> PowerSet(int sz);
 *
 *   // запросы
 * // возвращает пересечение текущего множества
 * // с множеством set
 *   public PowerSet<T> Intersection(PowerSet<T> set);
 *
 * // возвращает объединение текущего множества
 * // и множества set
 *   public PowerSet<T> Union(PowerSet<T> set);
 *
 * // возвращает разницу между текущим множеством
 * // и множеством set
 *   public PowerSet<T> Difference(PowerSet<T> set);
 *
 * // проверка, будет ли set подмножеством
 * // текущего множества
 *   public bool IsSubset(PowerSet<T> set);
 *
 *
 * Обратите внимание, что операции Intersection, Union и Difference не требуют ни предусловий, ни постусловий.
 * Они замкнуты: корректно и полностью определены на типе данных (структуре данных) "множество".
 * Более того, пользователю не нужно заботиться об ограничениях на максимальное количество элементов, например, при операции Union():
 * корректная реализация скрыто учтёт и задаст правильный максимальный размер итогового множества.
 */